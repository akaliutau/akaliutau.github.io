<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>I am starting a series of technical essays with aim to describe advanced techniques/heuristics in algorithms’ design, and this article is going to be the opening one. This topic is often under-represented in textbooks and algorithm handbooks. Quite often you can find in there the final solution, but you get zero hints about <em>how</em> the author actually invented this algorithm. In addition, the logical, deductive way of explanations how the solution was found is more a wish of brain to stick labels and see direct road, rather than objective reflections about how all elements of puzzle were actually put together. The internal kitchen, the secret laboratory of those subtle thought processes — that is what we will be looking for.</p> <p>The technical complexity of problems which I picked up as examples is not very high, the full solution can be designed and coded in 10–15 minutes, and due to this very fact one can quite likely meet these (or similar) problems on interview at FAANG companies</p> <p>Let’s get started! Today we will take a look at <a href="https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/" rel="external nofollow noopener" target="_blank">one simple problem</a> tied with re-shuffling the parts of string.</p> <blockquote><em>You are given a binary string s. In one second, all occurrences of 01 are simultaneously replaced with 10. This process repeats until no occurrences of 01 exist.</em></blockquote> <blockquote><em>Return the number of seconds needed to complete this process.</em></blockquote> <p>And here is an example:</p> <p>t = 0 sec : 001011</p> <p>t = 1 sec : 010101</p> <p>t = 2 sec : 101010</p> <p>t = 3 sec : 110100</p> <p>t = 4 sec : 111000</p> <p>We are expecting to get 4 seconds as an answer</p> <p>This problem is from the class of “transformations of something (binary strings in our case) in accordance to some rules”. Usually we are asked about the number of steps to reach some specific state, or any other questions about the process and its result.</p> <p>This problem can be solved in many ways, but it’s a good idea to start from the most straightforward one — a brute force approach. To do that we have first of all to identify the action (transformation of string in our case) and then to build the <em>simulation of</em> this process. Working simulation is going to be a tool which gives us the answer to all our questions.</p> <p>For our case we have to code two methods — the first one to check that we indeed have reached the final state, and the second one — to implement transformation itself.</p> <p>The implementation of the first method is obvious — we have to iterate through all characters comparing two neighboring ones, looking for the pattern 01. If found, this means we do not have a solution yet, because it’s easy to see that the final string — the result of transformation steps — can only contain patterns 11, or 00, or 10 (true — if there is no 01 in string, it cannot be transformed anymore in accordance with described procedure, can it?).</p> <p>The transformation procedure itself is straightforward as well — on each step we have to make a copy of input string and generate a new one on its basis in accordance with rules defined in problem statement.</p> <p>Obviously we have to count the number of steps taken — because this is exactly what we are asked.</p> <p>What is the time and space complexity of this approach? Well, we are using a double buffer for initial string, so if the size of string is <em>n</em> characters, we will need an additional space of size <em>n</em>, hence the space complexity is <em>O(n)</em>. We can improve it to <em>O(1)</em>, but it’s out of scope of this article.</p> <p>As for the time complexity, we’re going through all characters in the given string on each iteration-transformation, and in worst case scenario we will need to perform <em>n</em> such iterations, so the answer is <em>O(n²)</em> which is not very fast.</p> <p>Now we have to take a short break, look around and answer one simple question:</p> <blockquote>why did we consider brute force approach at all if it’s so slow and inefficient?</blockquote> <p>The answer is — to create a correct solution which <em>works</em> and which gives us the correct answer to any input. As a result we can generate a <em>golden set of test cases</em> to validate the correctness of more sophisticated solutions, with more subtle and non-trivial logic. Sometimes (not always, but sometimes) to find a mathematical proof for correctness of some non-trivial algorithm could be more difficult than to solve the problem itself. The validation of such algorithm on input-output pairs from the generated golden set can be the easiest way to get some more or less solid evidences of correctness of this algorithm (this is also known as <em>empirical proof of algorithm</em> — in real world of advanced mathematics one can meet those proofs more often than you think)</p> <p>In order to demonstrate the logic and to visualize the step-by-step dynamic of transformations, I used a brute force approach to generate 20 steps of transformations for the following random string (it contains 20 ones and 17 zeros)</p> <p>1001111111110001011001110000000110101</p> <p>And here is a spaghetti-like visualization of these transformations. I marked with yellow color the paths of 1s on the their way to final position, so you can literally see the dynamics of their moves.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/779/1*tB8IukdMG6rsVXFy2cHm1w.png"></figure> <p>It’s easy to see, that the answer to the question asked in this problem is the length of the rightmost path, which shows the trajectory of the rightmost 1.</p> <p>It’s obvious, that the shortest path should be a diagonal with length equals to the number of 0s to the left of the aforementioned rightmost 1.</p> <p>In this case we have a 17 such zeros, and the lower boundary for our answer is 17.</p> <p>But we can see that the actual length of path is <em>increased </em>due to some delays in moves of 1s (I marked these delays with red color). This is because one can move 1 to the left <strong>if and only if the left-side neighbor is 0</strong>. One can see that in case of contiguous sequence of 1s we have a blocker, or queue, which actually causes these delays.</p> <p>Also it’s easy to see that these queues are gradually disappearing on each transformation, and this disappearing is happening with speed modulated by the flow of 0s and 1s (the queue is growing when we meet 1s and shrinking otherwise)</p> <p>This gives us the hint how to build a super efficient algorithm to crack the problem.</p> <p>First, we will start from evaluation of the lower boundary for the answer, identifying the rightmost 1 and counting the number of 0s to the left of it.</p> <p>Next, iterating through all characters in string starting from the beginning till the last 1, we have to evaluate the possible delays in movement of 1s due to contiguous sequence of 1s. So each time we meet such continuous blocks we are increasing the excess delay, otherwise in case of 0s we are decreasing the excess. The answer to the question asked in problem will be our lower boundary <em>plus</em> the excess delay we’ve just calculated on the last step.</p> <p>What is the time and space complexity of this approach? Well, we are not using any buffers for initial string now, so the space complexity is <em>O(1)</em>, i.e. constant space.</p> <p>As for the time complexity, we have to iterate through all chars in string twice, so it’s going to be <em>O(2n)</em> which is close to theoretically best possible solution<em> O(n)</em>.</p> <p>And this is what we are eating today thinking about binary strings:</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*su5LzyKAQDYOqi5lqDv3Ew.jpeg"><figcaption>Pasta Puttanesca con aglio, olive e carpisti</figcaption></figure> <h3>References</h3> <p>[1] the source code of solutions —<a href="https://github.com/akaliutau/cs-problems-revisited/blob/fc23e08a8d2332d1bdaf7d861f4dc871246a713f/src/main/java/problem/advancedtopics/Solution357.java" rel="external nofollow noopener" target="_blank"> brute force</a> and <a href="https://github.com/akaliutau/cs-problems-revisited/blob/fc23e08a8d2332d1bdaf7d861f4dc871246a713f/src/main/java/problem/advancedtopics/Solution357opt.java" rel="external nofollow noopener" target="_blank">optimized</a></p> <p>[2] a recipe for todays dinner: <a href="https://www.simplyrecipes.com/recipes/pasta_puttanesca/" rel="external nofollow noopener" target="_blank">https://www.simplyrecipes.com/recipes/pasta_puttanesca/</a></p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=293619b228d6" width="1" height="1" alt=""></p> </body></html>